% DEMONSTRATION OF FBD  
close all; clear all;
% Arrays to store p-values
N = 100;

pVals_Positive = zeros(N, 1);
pVals_Negative = zeros(N, 1);
levels = {[1, 2, 3, 4]};
nse = 1;
reps_pos = 20;
vars_pos = 1200;

rng('shuffle');
plot_idx = randi(N);

%% Loop through N simulations
for i = 1:N

% Positive
[X1, X2, F1, F2, szPos] = simul_data('pos', levels, reps_pos, vars_pos, nse, 0.4, 'both');

[~, parglmo1] = parglm(X1 - mean(X1), F1, 'Preprocessing', 0); %Force the coding matrix to ignore column of ones.
[~, parglmo2] = parglm(X2 - mean(X2), F2, 'Preprocessing', 0);

[p_Pos, ~, ~, ~, Fd_pos,Fp_pos] = fbd(parglmo1, parglmo2, 2000);

% Negative
[X1_neg, X2_neg, F1_neg, F2_neg, szNeg] = simul_data('neg', levels, reps_pos, vars_pos, nse, 0.4, 'both');

[~, parglmo1_neg] = parglm(X1_neg - mean(X1_neg), F1_neg, 'Preprocessing', 0);
[~, parglmo2_neg] = parglm(X2_neg - mean(X2_neg), F2_neg, 'Preprocessing', 0);

[p_Neg, ~, ~, ~, Fd_neg,Fp_neg] = fbd(parglmo1_neg, parglmo2_neg, 2000);

%disp(szPos); disp(szNeg);

fprintf('Simulation %d complete\n',i)

if i == plot_idx
    % Prepare data for plotting
    Fp_pos_plt = Fp_pos; % Store the positive F statistic for plotting
    Fp_neg_plt = Fp_neg; % Store the negative F statistic for plotting
    Fd_pos_plt = Fd_pos; % Store the positive critical value for plotting
    Fd_neg_plt = Fd_neg; % Store the negative critical value for plotting
    disp(p_Pos)
end
pVals_Negative(i) = p_Neg;
pVals_Positive(i) = p_Pos;

end


%% ------------------ Plot results ------------------
set(groot,'defaultTextInterpreter','latex');        % text objects
set(groot,'defaultLegendInterpreter','latex');      % legend
set(groot,'defaultAxesTickLabelInterpreter','latex'); % tick labels

figure('Name','Distribution of p-values across simulations');
hold on; box on;

% Combine both vectors to determine common bin edges
all_p = [pVals_Positive(:); pVals_Negative(:)];
edges = linspace(min(all_p), max(all_p), 20); % or however many bins you want

% Plot both histograms with the same edges
histogram(pVals_Positive, edges, 'FaceColor', 'b', 'FaceAlpha', 0.5);
histogram(pVals_Negative, edges, 'FaceColor', 'r', 'FaceAlpha', 0.5);

xlabel('p-value');
ylabel('Frequency');
title('Negative Case (red) vs Positive case (blue)');
legend({'Positive','Negative'});
box on;
hold off;

%CDF Plot
figure('Name', 'Empirical CDF Plot', 'Units','inches','Position',[1 1 7 6]);  % larger figure size
hold on;
alpha = linspace(0,1,2000);

R_alt  = arrayfun(@(a) mean(pVals_Positive  <= a), alpha);
R_nul  = arrayfun(@(a) mean(pVals_Negative  <= a), alpha);
plot(alpha, alpha, 'LineWidth', 3, 'Color', [0,0,0,0.5],'LineStyle',':'); % y = x reference line
plot(alpha, R_nul, 'LineWidth', 3, 'Color', [0 0 1 0.5]);
plot(alpha, R_alt, 'LineWidth', 3, 'Color', [1 0 0 0.5]);

xlabel('Significance cutoff $\alpha$');
ylabel('Power');
legend('$p$ = $\alpha$','Alternative', 'Null', 'Location', 'southeast');
title('Empirical CDF Plot')

axis equal 
grid on;
ax = gca;
ax.XGrid = 'on';
ax.YGrid = 'on';
ax.GridAlpha = 0.3;       % transparency of grid lines
ax.MinorGridLineStyle = '-';
%ax.XMinorGrid = 'on';
%ax.YMinorGrid = 'on';
ax.XTick = 0:0.1:1;
ax.YTick = 0:0.1:1;

xlim([0,1])
ylim([0,1])

set(gca, 'FontName', 'Arial', ...     % clean font
         'FontSize', 16, ...          % larger tick labels
         'LineWidth', 1, ...        % thicker axis lines
         'Box', 'off');               % remove top/right box lines

% Enlarge labels & title
ax = gca;
ax.XLabel.FontSize = 15;
ax.YLabel.FontSize = 15;
ax.Title.FontSize  = 15;

% Enlarge legend
lgd = legend;
lgd.FontSize = 14;

%% ===================== POSITIVE CASE: Chi-square (df=1) =====================
figure(); hold on; box on;

histogram(Fp_pos_plt, 'Normalization','pdf', 'NumBins',150, 'FaceAlpha',0.5);

x = linspace(0, max(Fp_pos_plt), 500);
plot(x, chi2pdf(x,1), 'LineWidth',2);

xline(Fd_pos_plt, '--', 'LineWidth',2);

xlabel('$\chi^2 = T^2$');
ylabel('Probability density');
title('Positive case: $\chi^2_1$ overlay on studentized null');
legend({'$T_p^2$ (hist)','$\chi^2$ pdf (df=1)','$T_d^2$'}, 'Location','best');

hold off;


%% ===================== NEGATIVE CASE: Chi-square (df=1) =====================
figure(); hold on; box on;

histogram(Fp_neg_plt, 'Normalization','pdf', 'NumBins',150, 'FaceAlpha',0.5);

x = linspace(0, max(Fp_neg_plt), 500);
plot(x, chi2pdf(x,1), 'LineWidth',2);

xline(Fd_neg_plt, '--', 'LineWidth',2);

xlabel('$\chi^2 = T^2$');
ylabel('Probability density');
title('Negative case: $\chi^2_1$ overlay on studentized null');
legend({'$T_p^2$ (hist)','$\chi^2$ pdf (df=1)','$T_d^2$'}, 'Location','best');

hold off;

%% ------------------ Helper Functions ------------------

function [X1, X2, F1, F2, sz] = simul_data(mode, levels, reps_pos, vars_pos, nse, splitFrac, splitMode)
%SIMUL_DATA  Simulate data for FBD experiments (positive/negative cases).
%
%   [X1,X2,F1,F2,sz] = simul_data('pos', levels, reps_pos, vars_pos, nse, 0.4, 'both');
%   [X1,X2,F1,F2,sz] = simul_data('neg', levels, reps_pos, vars_pos, nse, 0.4, 'both');

    if nargin < 7 || isempty(splitMode), splitMode = 'both'; end
    if nargin < 6 || isempty(splitFrac), splitFrac = 0.4; end

    mode = lower(string(mode));
    if mode == "positive", mode = "pos"; end
    if mode == "negative", mode = "neg"; end

    switch mode
        case "pos"
            % ---- simulate one big matrix, shuffle, then blockDiagonalSampling ----
            [X, F] = local_sim_one(levels, reps_pos, vars_pos, nse);

            % Shuffle row order (exactly as in your code)
            rp = randperm(size(X,1));
            X = X(rp,:);
            F = F(rp,:);

            % Split data into X1, X2
            [X1, X2] = blockDiagonalSampling(X, splitFrac, splitMode);
            F1 = F(1:size(X1,1), :);
            F2 = F(size(X1,1)+1:end, :);

            sz = struct();
            sz.mode = 'pos';
            sz.X_full = size(X);
            sz.F_full = size(F);
            sz.X1 = size(X1);  sz.X2 = size(X2);
            sz.F1 = size(F1);  sz.F2 = size(F2);

        case "neg"
            % ---- simulate X1 and X2 independently (exactly like your code path) ----
            reps1 = floor(splitFrac * reps_pos);
            vars1 = floor(splitFrac * vars_pos);

            [X1, F1] = local_sim_one(levels, reps1, vars1, nse);

            reps2 = floor((1 - splitFrac) * reps_pos);
            vars2 = floor((1 - splitFrac) * vars_pos);

            [X2, F2] = local_sim_one(levels, reps2, vars2, nse);

            sz = struct();
            sz.mode = 'neg';
            sz.X1 = size(X1);  sz.X2 = size(X2);
            sz.F1 = size(F1);  sz.F2 = size(F2);
            sz.reps1 = reps1;  sz.vars1 = vars1;
            sz.reps2 = reps2;  sz.vars2 = vars2;

        otherwise
            error('simul_data:badMode', 'mode must be ''pos'' or ''neg''.');
    end
end

% ----------------------- local helper -----------------------
function [X, F] = local_sim_one(levels, reps, vars, nse)
%Prevent data leakage, by wrapper function
    F = createDesign(levels,'Replicates',reps);
    X = zeros(size(F,1),vars);
    for ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars) ...
            + nse.*repmat(randn(1,vars),length(find(F(:,1) == levels{1}(ii))),1);
    end
end


function [block1, block2] = blockDiagonalSampling(X, p, mode)
% blockDiagonalSampling Subsets a block diagonal sampling from a matrix.
% REFACTORED AUG 2025 - 'rows' no longer corresponds to an intermediate calculation
% to describe the proportion of data to be sampled. This caused a
% significant error.
%
%   [block1, block2] = blockDiagonalSampling(X, p, mode) extracts two
%   rectangular submatrices from the input matrix X according to the
%   specified sampling percentage p. The parameter 'mode' determines how
%   the matrix is partitioned:
%
%       'rows'  - Split by rows only: the first block takes the first 
%                 round(m*p) rows (all columns), and the second block uses
%                 the remaining rows.
%
%       'cols'  - Split by columns only: the first block takes the first 
%                 round(n*p) columns (all rows), and the second block uses
%                 the remaining columns.
%
%       'both'  - Split both rows and columns: the first block is the top
%                 left submatrix with round(m*p) rows and round(n*p) columns,
%                 and the second block is the bottom right submatrix using
%                 the remaining rows and columns.
%
%   Inputs:
%       X    - The input m x n matrix.
%       p    - Sampling percentage (0 < p < 1). E.g., 0.3 means 30%.
%       mode - A string with options: 'rows', 'cols', or 'both'.
%
%   Outputs:
%       block1 - The submatrix corresponding to the top left block.
%       block2 - The submatrix corresponding to the bottom right block.
%

    if nargin < 3
        mode = 'both'; % Default mode if not provided.
    end

    [m, n] = size(X);

    switch lower(mode)
        case 'rows'
            % Determine number of rows for block 1
            r1 = round(m * p);
            block1 = X(1:r1, :);        % Top rows (all columns)
            block2 = X(r1+1:end, :);      % Remaining rows (all columns)
            
        case 'cols'
            % Determine number of columns for block 1
            c1 = round(n * p);
            block1 = X(:, 1:c1);        % Left columns (all rows)
            block2 = X(:, c1+1:end);      % Remaining columns (all rows)
            
        case 'both'
            % Determine both rows and columns for block 1
            r1 = round(m * p);
            c1 = round(n * p);
            block1 = X(1:r1, 1:c1);      % Top left block
            block2 = X(r1+1:end, c1+1:end); % Bottom right block
            
        otherwise
            error('Unknown mode. Please use ''rows'', ''cols'', or ''both''.');
    end
end


function [p,T1oe,T1r,T2oe,Td,Tp] = fbd(parglmoA, parglmoB, n_perms)

X1 = parglmoA.data;
X2 = parglmoB.data;

F1 = parglmoA.design;
F2 = parglmoB.design;

[F1,idx] = sort(F1,"ascend");
X1 = X1(idx,:);
Z1 = parglmoA.D(idx,:);

[F2,idx] = sort(F2,"ascend");
X2 = X2(idx,:);
Z2 = parglmoB.D(idx,:);

B1hat = pinv(Z1)*X1;
X1n = Z1*B1hat;
E1 = X1 - X1n;

B2hat = pinv(Z2)*X2;
X2n = Z2*B2hat;
E2 = X2 - X2n; 

% Scores calculation
[~, ~, V1] = svds(X1n, rank(X1n));
[~, ~, V2] = svds(X2n, rank(X2n));

T1o = X1n * V1 ;
T2o = X2n * V2 ;

%Calculate diasmetic statistic
[R,P,T1u,Er,Ep,Vo] = diasmetic_rotations(T1o,T2o,F1,F2);

Eo = T1u*(P-R);

% Incorporate noise and apply the rotation
T1oe = ((X1n + E1) * V1);    % T1 with noise (before rotation)
T1r = T1oe * R;         % T1 after rotation
T2oe = (X2n + E2) * V2;        % T2 after noise (no rotation)

N = size(T1u,1);
M = size(X1,2);

Sobs  = (Er'*Er + Ep'*Ep) / (N);
Siobs = pinv(Sobs);
Lobs  = chol(Siobs,'lower');

Fd = norm(T1u*Lobs*(eye(N-1) - P + R),'fro')^2;

Fp = zeros([1,n_perms]);

for ii = 1:n_perms
    perms = randperm(size(E1,1));
    Eperm = E1(perms,:);
    Xperm = X1n + Eperm;

    pD1 =  pinv(Z1);
    Bperm = pD1*Xperm;
    X1perm = Z1*Bperm;
    
    Tpm = X1perm * V1;
    [Tpu, ~, ~] = uniquetol(Tpm,1e-6, 'ByRows', true, 'PreserveRange', true);
    Tpu = Tpu * Vo;
    Fp(ii) = norm(Tpu*Lobs*(eye(N-1) - P + R),'fro')^2;

    %[~,~, Qp] = svd(Tpu);
    %Fp(ii) = norm((eye(N-1) - pinv(Tpu*R)*Tpu*P)*Lobs,'fro')^2;
    %Fp(ii) = norm(Xperm*(eye(M) - pinv(X1perm)*Xperm)*V1*(P-R)*Lobs,'fro')^2;
    %Fp(ii) = norm(Tpu*(P-R)*Lobs*(eye(N-1) - Qp*Qp'),'fro')^2;
    %Fp(ii) = norm(Tpu*(P - R)*Lobs,'fro')^2;
    %Fp(ii) = norm((eye(N-1) - Tpu'*Tpu)*(P-R)*Lobs ,'fro')^2;
end

%Studentization of the test statistic

Td = (Fd - mean(Fp)) / std(Fp);
Td = Td^2;
Tp = (Fp - mean(Fp)) / std(Fp);
Tp = Tp.^2; 
%p = (sum(Td >= Tp) + 1) / (n_perms + 1);
p = (sum(Tp >= Td) + 1) / (n_perms + 1); 

end


function [R,P,T1u,Er,Ep,Vo] = diasmetic_rotations(T1o,T2o,F1,F2)

[T1u, ord1, ~] = uniquetol(T1o,1e-6, 'ByRows', true, 'PreserveRange', true);
[T2u, ord2, ~] = uniquetol(T2o,1e-6, 'ByRows', true, 'PreserveRange', true);

[U1,S1,Vo] = svds(T1u,size(T1o,2)); %re-orthogonalize. 
[U2,S2,~] = svds(T2u,size(T1o,2));

T1u = U1*S1;
T2u = U2*S2;

lvls1 = F1(ord1, 1);
lvls2 = F2(ord2, 1);

%Orient levels according to T1u
[~, perm_idx] = ismember(lvls1, lvls2);
n = numel(lvls1);
P = eye(n);
P = P(perm_idx, :);
T2ua = P * T2u;

M = T1u' * T2ua;
[Up, ~, Vp] = svd(M);
R = Up * Vp';  % Rotation matrix
Er = T1u * R - T2ua;

n = size(R, 1);

% Form the cost matrix as the negative absolute value of R
costMat = -abs(R);

% Solve the assignment problem using matchpairs (Hungarian algorithm)
% The second argument (-Inf) ensures a complete assignment.
assignment = matchpairs(costMat, 1e6);

% Initialize the signed permutation matrix P
P = zeros(n);

% For each assignment, set the corresponding entry in P to the sign of R
for k = 1:size(assignment, 1)
    i = assignment(k, 1);
    j = assignment(k, 2);
    if R(i, j) >= 0
        P(i, j) = 1;
    else
        P(i, j) = -1;
    end
end

Ep = T1u*P - T2ua;

end