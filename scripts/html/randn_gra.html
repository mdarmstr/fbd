<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>randn_gra</title>
<meta name="generator" content="MATLAB 25.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-12-02">
<meta name="DC.source" content="randn_gra.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">TODO</a>
</li>
<li>
<a href="#3">Parameters</a>
</li>
<li>
<a href="#4">Loop through N simulations</a>
</li>
<li>
<a href="#5">------------------ Plot results ------------------</a>
</li>
<li>
<a href="#7">------------------ Helper Functions ------------------</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">function</span> randn_gra(N,levels,nse)
</pre>
<h2 id="2">TODO</h2>
<p>Drop levels, fewer replicates NEVER simulate what's going on in the residuals Fix loop error</p>
<h2 id="3">Parameters</h2>
<pre class="codeinput">
<span class="comment">%N = 100;</span>

<span class="comment">% Arrays to store p-values</span>
pVals_Positive = zeros(N, 1);
pVals_Negative = zeros(N, 1);
<span class="comment">%levels = {[1, 2, 3]};</span>
<span class="comment">%nse = 1;</span>
rng(<span class="string">'default'</span>);
</pre>
<pre class="codeoutput error">Not enough input arguments.

Error in randn_gra (line 11)
pVals_Positive = zeros(N, 1);
                       ^</pre>
<h2 id="4">Loop through N simulations</h2>
<pre class="codeinput">
<span class="keyword">for</span> i = 1:N

    <span class="comment">% ------------------ POSITIVE CASE ------------------</span>
    reps_pos = 20;
    vars_pos = 300;

    <span class="comment">% Prepare random effect levels</span>
    F = createDesign(levels,<span class="string">'Replicates'</span>,reps_pos);

    X = zeros(size(F,1),vars_pos);
    <span class="keyword">for</span> ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars_pos) + nse.*repmat(randn(1,vars_pos),length(find(F(:,1) == levels{1}(ii))),1);
    <span class="keyword">end</span>

    <span class="comment">% Shuffle row order</span>
    rp = randperm(size(X,1));
    X = X(rp,:);
    F = F(rp,:);

    <span class="comment">% Split data into X1, X2</span>
    [X1, X2] = blockDiagonalSampling(X, 0.4, <span class="string">'rows'</span>);
    F1 = F(1:size(X1,1), :);
    F2 = F(size(X1,1)+1:end, :);

    <span class="comment">% Fit parglm</span>
    [~, parglmo1] = parglm(X1, F1, <span class="string">'Preprocessing'</span>, 1);
    [~, parglmo2] = parglm(X2, F2, <span class="string">'Preprocessing'</span>, 1);

    <span class="comment">% ascao1 = asca(parglmo1);</span>
    <span class="comment">% ascao2 = asca(parglmo2);</span>
    <span class="comment">%</span>
    <span class="comment">% scores(ascao1.factors{1},'ObsClass',F1(:,1),'Title','ASCA1')</span>
    <span class="comment">% scores(ascao2.factors{1},'ObsClass',F2(:,1),'Title','ASCA2')</span>


    <span class="comment">% Run fbd</span>
    [p_Pos, ~, ~, ~] = fbd(parglmo1, parglmo2, F1, F2, 1, 1000);

    pVals_Positive(i) = p_Pos;
    fprintf(<span class="string">'Postive simulation %d complete\n'</span>,i)

    <span class="comment">% ------------------ NEGATIVE CASE ------------------</span>
    reps = floor(0.4*reps_pos);
    vars = floor(0.6*vars_pos);

    F = createDesign(levels,<span class="string">'Replicates'</span>,reps);

    X = zeros(size(F,1),vars);
    <span class="keyword">for</span> ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars) + nse.*repmat(randn(1,vars),length(find(F(:,1) == levels{1}(ii))),1);
    <span class="keyword">end</span>

    X1_neg = X;
    F1_neg = F;

    reps = floor(0.6*reps_pos);
    vars = floor(0.6*vars_pos);

    F = createDesign(levels, <span class="string">'Replicates'</span>, reps);
    X = zeros(size(F,1),vars);
    <span class="keyword">for</span> ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars) + nse.*repmat(randn(1,vars),length(find(F(:,1) == levels{1}(ii))),1);
    <span class="keyword">end</span>

    X2_neg = X;  <span class="comment">% entire dataset for negative</span>
    F2_neg = F;

    <span class="comment">% For example, we can keep X1, F1 from above to test a "no-change" scenario:</span>
    [~, parglmo1_neg] = parglm(X1_neg, F1_neg, <span class="string">'Preprocessing'</span>, 1);
    [~, parglmo2_neg] = parglm(X2_neg, F2_neg, <span class="string">'Preprocessing'</span>, 1);

    <span class="comment">% ascao1 = asca(parglmo1_neg);</span>
    <span class="comment">% ascao2 = asca(parglmo2_neg);</span>
    <span class="comment">%</span>
    <span class="comment">% scores(ascao1.factors{1},'ObsClass',ascao1.design(:,1),'Title','ASCA1')</span>
    <span class="comment">% scores(ascao2.factors{1},'ObsClass',ascao2.design(:,1),'Title','ASCA1')</span>

    [p_Neg, ~, ~, ~] = fbd(parglmo1_neg, parglmo2_neg, F1_neg, F2_neg, 1, 1000);

    pVals_Negative(i) = p_Neg;
    fprintf(<span class="string">'Negative simulation %d complete\n'</span>,i)

<span class="keyword">end</span>
</pre>
<h2 id="5">------------------ Plot results ------------------</h2>
<pre class="codeinput">figure(<span class="string">'Name'</span>,<span class="string">'Distribution of p-values across simulations'</span>,<span class="string">'Color'</span>,<span class="string">'w'</span>);
hold <span class="string">on</span>; box <span class="string">on</span>;

<span class="comment">% Combine both vectors to determine common bin edges</span>
all_p = [pVals_Positive(:); pVals_Negative(:)];
edges = linspace(min(all_p), max(all_p), 20); <span class="comment">% or however many bins you want</span>

<span class="comment">% Plot both histograms with the same edges</span>
histogram(pVals_Positive, edges, <span class="string">'FaceColor'</span>, <span class="string">'b'</span>, <span class="string">'FaceAlpha'</span>, 0.5);
histogram(pVals_Negative, edges, <span class="string">'FaceColor'</span>, <span class="string">'r'</span>, <span class="string">'FaceAlpha'</span>, 0.5);

xlabel(<span class="string">'p-value'</span>);
ylabel(<span class="string">'Frequency'</span>);
title(<span class="string">'Negative Case (red) vs Positive case (blue)'</span>);
legend({<span class="string">'Positive'</span>,<span class="string">'Negative'</span>});
box <span class="string">on</span>;
hold <span class="string">off</span>;

figure(2)
cdf_plot(pVals_Positive,pVals_Negative, <span class="string">'Matrix Distance'</span>);
snapnow;
</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<h2 id="7">------------------ Helper Functions ------------------</h2>
<pre class="codeinput">
<span class="keyword">function</span> [block1, block2] = blockDiagonalSampling(X, p, mode)
<span class="comment">% blockDiagonalSampling Subsets a block diagonal sampling from a matrix.</span>
<span class="comment">% REFACTORED AUG 2025 - 'rows' no longer corresponds to an intermediate calculation</span>
<span class="comment">% to describe the proportion of data to be sampled. This caused a</span>
<span class="comment">% significant error.</span>
<span class="comment">%</span>
<span class="comment">%   [block1, block2] = blockDiagonalSampling(X, p, mode) extracts two</span>
<span class="comment">%   rectangular submatrices from the input matrix X according to the</span>
<span class="comment">%   specified sampling percentage p. The parameter 'mode' determines how</span>
<span class="comment">%   the matrix is partitioned:</span>
<span class="comment">%</span>
<span class="comment">%       'rows'  - Split by rows only: the first block takes the first</span>
<span class="comment">%                 round(m*p) rows (all columns), and the second block uses</span>
<span class="comment">%                 the remaining rows.</span>
<span class="comment">%</span>
<span class="comment">%       'cols'  - Split by columns only: the first block takes the first</span>
<span class="comment">%                 round(n*p) columns (all rows), and the second block uses</span>
<span class="comment">%                 the remaining columns.</span>
<span class="comment">%</span>
<span class="comment">%       'both'  - Split both rows and columns: the first block is the top</span>
<span class="comment">%                 left submatrix with round(m*p) rows and round(n*p) columns,</span>
<span class="comment">%                 and the second block is the bottom right submatrix using</span>
<span class="comment">%                 the remaining rows and columns.</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%       X    - The input m x n matrix.</span>
<span class="comment">%       p    - Sampling percentage (0 &lt; p &lt; 1). E.g., 0.3 means 30%.</span>
<span class="comment">%       mode - A string with options: 'rows', 'cols', or 'both'.</span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%       block1 - The submatrix corresponding to the top left block.</span>
<span class="comment">%       block2 - The submatrix corresponding to the bottom right block.</span>
<span class="comment">%</span>

    <span class="keyword">if</span> nargin &lt; 3
        mode = <span class="string">'both'</span>; <span class="comment">% Default mode if not provided.</span>
    <span class="keyword">end</span>

    [m, n] = size(X);

    <span class="keyword">switch</span> lower(mode)
        <span class="keyword">case</span> <span class="string">'rows'</span>
            <span class="comment">% Determine number of rows for block 1</span>
            r1 = round(m * p);
            block1 = X(1:r1, :);        <span class="comment">% Top rows (all columns)</span>
            block2 = X(r1+1:end, :);      <span class="comment">% Remaining rows (all columns)</span>

        <span class="keyword">case</span> <span class="string">'cols'</span>
            <span class="comment">% Determine number of columns for block 1</span>
            c1 = round(n * p);
            block1 = X(:, 1:c1);        <span class="comment">% Left columns (all rows)</span>
            block2 = X(:, c1+1:end);      <span class="comment">% Remaining columns (all rows)</span>

        <span class="keyword">case</span> <span class="string">'both'</span>
            <span class="comment">% Determine both rows and columns for block 1</span>
            r1 = round(m * p);
            c1 = round(n * p);
            block1 = X(1:r1, 1:c1);      <span class="comment">% Top left block</span>
            block2 = X(r1+1:end, c1+1:end); <span class="comment">% Bottom right block</span>

        <span class="keyword">otherwise</span>
            error(<span class="string">'Unknown mode. Please use ''rows'', ''cols'', or ''both''.'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [p,T1oe,T1r,T2oe] = fbd(parglmoA, parglmoB, F1, F2, fctrs, n_perms)
<span class="comment">% PROTOTYPE PERMUTATION TEST CURRENTLY WORKING OKAY AS OF NOV 2025</span>

X1 = parglmoA.data;
<span class="comment">%X2 = parglmoB.data;</span>

X1ne = parglmoA.residuals;
X2ne = parglmoB.residuals;

X1n = parglmoA.factors{fctrs(1)}.matrix;
X2n = parglmoB.factors{fctrs(1)}.matrix;

D1 = parglmoA.D(:,parglmoA.factors{fctrs(1)}.Dvars);
<span class="comment">%D2 = parglmoB.D(:,parglmoB.factors{fctrs(1)}.Dvars);</span>

<span class="comment">% Scores calculation</span>
[~, ~, V1] = svds(X1n, rank(X1n));
[~, ~, V2] = svds(X2n, rank(X2n));

<span class="comment">% Data pre-treatment no longer appears to be necessary.</span>
<span class="comment">%[V1,T] = rotatefactors(V1,'Method','varimax','maxit',5000,'reltol',1e-12);</span>
<span class="comment">%V2 = rotatefactors(V2,'Method','varimax','maxit',5000,'reltol',1e-12);</span>

T1o = X1n * V1;
T2o = X2n * V2;

<span class="comment">%Calculate diasmetic statistic</span>
[R,P,T1u,Er,Ep] = diasmetic_rotations(T1o,T2o,F1,F2);

<span class="comment">%W = X1n*pinv(X1); %previous idea for permutation test.</span>

Bhat = pinv(D1)*X1;
Xhat = D1*Bhat;
E    = X1 - Xhat;

<span class="comment">% Incorporate noise and apply the rotation</span>
T1oe = ((X1n + X1ne) * V1);    <span class="comment">% T1 with noise (before rotation)</span>
T1r = T1oe * R;         <span class="comment">% T1 after rotation</span>
T2oe = (X2n + X2ne) * V2;        <span class="comment">% T2 after noise (no rotation)</span>

N = size(T1u,1);

[T2u, ~, ~] = uniquetol(T2o,1e-8, <span class="string">'ByRows'</span>, true, <span class="string">'PreserveRange'</span>, true);

Fd = trace(Er*(Er'*Ep)*Ep') / (norm(Er*Er',<span class="string">'fro'</span>)*norm(Ep*Ep',<span class="string">'fro'</span>));

Fp = zeros([1,n_perms]);

<span class="keyword">for</span> ii = 1:n_perms
    perms = randperm(size(E,1));
    <span class="comment">%Eperm = E(perms,:);</span>
    <span class="comment">%M = sign(rand(size(Eperm)) - 0.5);</span>
    <span class="comment">%Eperm = Eperm.*M;</span>
    Xperm = X1(perms,:);
    <span class="comment">%Xperm = Xhat + Eperm;</span>

    pD1 =  pinv(D1'*D1)*D1';
    Bperm = pD1*Xperm;
    X1perm = D1*Bperm;
    <span class="comment">%Es = Xperm - X1perm;</span>
    [~,~,Vpm] = svds(X1perm,rank(X1n));

    Tpm = (X1perm) * Vpm;
    [Rp,Pp,T1up,Erp,Epp] = diasmetic_rotations(Tpm,T2o,F1,F2);

    Fp(ii) = trace(Erp*(Erp'*Epp)*Epp') / (norm(Epp*Epp',<span class="string">'fro'</span>)*norm(Erp*Erp',<span class="string">'fro'</span>));
<span class="keyword">end</span>

p = (sum(Fp &lt;= Fd)+1) / (n_perms + 1);
<span class="comment">%p = Fd;</span>

<span class="comment">% Td  = (Fd - mean(Fp)) / std(Fp);</span>
<span class="comment">% Tp  = (Fp - mean(Fp)) / std(Fp);</span>
<span class="comment">%</span>
<span class="comment">% p = (sum(abs(Td) &lt;= abs(Tp)) + 1) / (n_perms + 1);</span>

<span class="keyword">end</span>


<span class="keyword">function</span> [R,P,T1u,Er,Ep] = diasmetic_rotations(T1o,T2o,F1,F2)

[T1u, ord1, ~] = uniquetol(T1o,1e-6, <span class="string">'ByRows'</span>, true, <span class="string">'PreserveRange'</span>, true);
[T2u, ord2, ~] = uniquetol(T2o,1e-6, <span class="string">'ByRows'</span>, true, <span class="string">'PreserveRange'</span>, true);

lvls1 = F1(ord1, 1);
lvls2 = F2(ord2, 1);

<span class="comment">%Orient levels according to T1u - should it be opposite?</span>
[~, perm_idx] = ismember(lvls1, lvls2);
n = numel(lvls1);
P = eye(n);
P = P(perm_idx, :);
T2ua = P * T2u;

M = T1u' * T2ua;
[Up, ~, Vp] = svd(M);
R = Up * Vp';  <span class="comment">% Rotation matrix</span>
Er = T1u * R - T2ua;

n = size(R, 1);

<span class="comment">% Form the cost matrix as the negative absolute value of R</span>
costMat = -abs(R);

<span class="comment">% Solve the assignment problem using matchpairs (Hungarian algorithm)</span>
<span class="comment">% The second argument (-Inf) ensures a complete assignment.</span>
assignment = matchpairs(costMat, 1e6);

<span class="comment">% Initialize the signed permutation matrix P</span>
P = zeros(n);

<span class="comment">% For each assignment, set the corresponding entry in P to the sign of R</span>
<span class="keyword">for</span> k = 1:size(assignment, 1)
    i = assignment(k, 1);
    j = assignment(k, 2);
    <span class="keyword">if</span> R(i, j) &gt;= 0
        P(i, j) = 1;
    <span class="keyword">else</span>
        P(i, j) = -1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

Ep = T1u*P - T2ua;

<span class="comment">%D = diag(sign(diag(T1u'*T2u)));</span>

<span class="comment">%T1u = T1u*D;</span>

<span class="comment">%T1u = T1u ./vecnorm(T1u);</span>

<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2025a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function randn_gra(N,levels,nse)
%% TODO
% Drop levels, fewer replicates
% NEVER simulate what's going on in the residuals
% Fix loop error

%% Parameters
%N = 100;           

% Arrays to store p-values
pVals_Positive = zeros(N, 1);
pVals_Negative = zeros(N, 1);
%levels = {[1, 2, 3]};
%nse = 1;
rng('default');

%% Loop through N simulations
for i = 1:N
    
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH POSITIVE CASE REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    reps_pos = 20;
    vars_pos = 300;

    % Prepare random effect levels
    F = createDesign(levels,'Replicates',reps_pos);

    X = zeros(size(F,1),vars_pos);
    for ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars_pos) + nse.*repmat(randn(1,vars_pos),length(find(F(:,1) == levels{1}(ii))),1);
    end

    % Shuffle row order
    rp = randperm(size(X,1));
    X = X(rp,:);
    F = F(rp,:);

    % Split data into X1, X2
    [X1, X2] = blockDiagonalSampling(X, 0.4, 'rows');
    F1 = F(1:size(X1,1), :);
    F2 = F(size(X1,1)+1:end, :);

    % Fit parglm
    [~, parglmo1] = parglm(X1, F1, 'Preprocessing', 1);
    [~, parglmo2] = parglm(X2, F2, 'Preprocessing', 1);

    % ascao1 = asca(parglmo1);
    % ascao2 = asca(parglmo2);
    % 
    % scores(ascao1.factors{1},'ObsClass',F1(:,1),'Title','ASCA1')
    % scores(ascao2.factors{1},'ObsClass',F2(:,1),'Title','ASCA2')


    % Run fbd
    [p_Pos, ~, ~, ~] = fbd(parglmo1, parglmo2, F1, F2, 1, 1000);

    pVals_Positive(i) = p_Pos;
    fprintf('Postive simulation %d complete\n',i)

    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH NEGATIVE CASE REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    reps = floor(0.4*reps_pos);
    vars = floor(0.6*vars_pos);

    F = createDesign(levels,'Replicates',reps);

    X = zeros(size(F,1),vars);
    for ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars) + nse.*repmat(randn(1,vars),length(find(F(:,1) == levels{1}(ii))),1);
    end

    X1_neg = X;
    F1_neg = F;

    reps = floor(0.6*reps_pos);
    vars = floor(0.6*vars_pos);

    F = createDesign(levels, 'Replicates', reps);
    X = zeros(size(F,1),vars);
    for ii = 1:length(levels{1})
        X(find(F(:,1) == levels{1}(ii)),:) = randn(length(find(F(:,1) == levels{1}(ii))),vars) + nse.*repmat(randn(1,vars),length(find(F(:,1) == levels{1}(ii))),1);
    end

    X2_neg = X;  % entire dataset for negative
    F2_neg = F;

    % For example, we can keep X1, F1 from above to test a "no-change" scenario:
    [~, parglmo1_neg] = parglm(X1_neg, F1_neg, 'Preprocessing', 1);
    [~, parglmo2_neg] = parglm(X2_neg, F2_neg, 'Preprocessing', 1);

    % ascao1 = asca(parglmo1_neg);
    % ascao2 = asca(parglmo2_neg);
    % 
    % scores(ascao1.factors{1},'ObsClass',ascao1.design(:,1),'Title','ASCA1')
    % scores(ascao2.factors{1},'ObsClass',ascao2.design(:,1),'Title','ASCA1')

    [p_Neg, ~, ~, ~] = fbd(parglmo1_neg, parglmo2_neg, F1_neg, F2_neg, 1, 1000);

    pVals_Negative(i) = p_Neg;
    fprintf('Negative simulation %d complete\n',i)

end

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Plot results REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
figure('Name','Distribution of p-values across simulations','Color','w');
hold on; box on;

% Combine both vectors to determine common bin edges
all_p = [pVals_Positive(:); pVals_Negative(:)];
edges = linspace(min(all_p), max(all_p), 20); % or however many bins you want

% Plot both histograms with the same edges
histogram(pVals_Positive, edges, 'FaceColor', 'b', 'FaceAlpha', 0.5);
histogram(pVals_Negative, edges, 'FaceColor', 'r', 'FaceAlpha', 0.5);

xlabel('p-value');
ylabel('Frequency');
title('Negative Case (red) vs Positive case (blue)');
legend({'Positive','Negative'});
box on;
hold off;

figure(2)
cdf_plot(pVals_Positive,pVals_Negative, 'Matrix Distance');
snapnow;


end

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Helper Functions REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function [block1, block2] = blockDiagonalSampling(X, p, mode)
% blockDiagonalSampling Subsets a block diagonal sampling from a matrix.
% REFACTORED AUG 2025 - 'rows' no longer corresponds to an intermediate calculation
% to describe the proportion of data to be sampled. This caused a
% significant error.
%
%   [block1, block2] = blockDiagonalSampling(X, p, mode) extracts two
%   rectangular submatrices from the input matrix X according to the
%   specified sampling percentage p. The parameter 'mode' determines how
%   the matrix is partitioned:
%
%       'rows'  - Split by rows only: the first block takes the first 
%                 round(m*p) rows (all columns), and the second block uses
%                 the remaining rows.
%
%       'cols'  - Split by columns only: the first block takes the first 
%                 round(n*p) columns (all rows), and the second block uses
%                 the remaining columns.
%
%       'both'  - Split both rows and columns: the first block is the top
%                 left submatrix with round(m*p) rows and round(n*p) columns,
%                 and the second block is the bottom right submatrix using
%                 the remaining rows and columns.
%
%   Inputs:
%       X    - The input m x n matrix.
%       p    - Sampling percentage (0 < p < 1). E.g., 0.3 means 30%.
%       mode - A string with options: 'rows', 'cols', or 'both'.
%
%   Outputs:
%       block1 - The submatrix corresponding to the top left block.
%       block2 - The submatrix corresponding to the bottom right block.
%

    if nargin < 3
        mode = 'both'; % Default mode if not provided.
    end

    [m, n] = size(X);

    switch lower(mode)
        case 'rows'
            % Determine number of rows for block 1
            r1 = round(m * p);
            block1 = X(1:r1, :);        % Top rows (all columns)
            block2 = X(r1+1:end, :);      % Remaining rows (all columns)
            
        case 'cols'
            % Determine number of columns for block 1
            c1 = round(n * p);
            block1 = X(:, 1:c1);        % Left columns (all rows)
            block2 = X(:, c1+1:end);      % Remaining columns (all rows)
            
        case 'both'
            % Determine both rows and columns for block 1
            r1 = round(m * p);
            c1 = round(n * p);
            block1 = X(1:r1, 1:c1);      % Top left block
            block2 = X(r1+1:end, c1+1:end); % Bottom right block
            
        otherwise
            error('Unknown mode. Please use ''rows'', ''cols'', or ''both''.');
    end
end


function [p,T1oe,T1r,T2oe] = fbd(parglmoA, parglmoB, F1, F2, fctrs, n_perms)
% PROTOTYPE PERMUTATION TEST CURRENTLY WORKING OKAY AS OF NOV 2025

X1 = parglmoA.data;
%X2 = parglmoB.data;

X1ne = parglmoA.residuals;
X2ne = parglmoB.residuals;

X1n = parglmoA.factors{fctrs(1)}.matrix;
X2n = parglmoB.factors{fctrs(1)}.matrix;

D1 = parglmoA.D(:,parglmoA.factors{fctrs(1)}.Dvars);
%D2 = parglmoB.D(:,parglmoB.factors{fctrs(1)}.Dvars);

% Scores calculation
[~, ~, V1] = svds(X1n, rank(X1n));
[~, ~, V2] = svds(X2n, rank(X2n));

% Data pre-treatment no longer appears to be necessary.
%[V1,T] = rotatefactors(V1,'Method','varimax','maxit',5000,'reltol',1e-12);
%V2 = rotatefactors(V2,'Method','varimax','maxit',5000,'reltol',1e-12);

T1o = X1n * V1;
T2o = X2n * V2;

%Calculate diasmetic statistic
[R,P,T1u,Er,Ep] = diasmetic_rotations(T1o,T2o,F1,F2);

%W = X1n*pinv(X1); %previous idea for permutation test.

Bhat = pinv(D1)*X1;
Xhat = D1*Bhat;
E    = X1 - Xhat;

% Incorporate noise and apply the rotation
T1oe = ((X1n + X1ne) * V1);    % T1 with noise (before rotation)
T1r = T1oe * R;         % T1 after rotation
T2oe = (X2n + X2ne) * V2;        % T2 after noise (no rotation)

N = size(T1u,1);

[T2u, ~, ~] = uniquetol(T2o,1e-8, 'ByRows', true, 'PreserveRange', true);

Fd = trace(Er*(Er'*Ep)*Ep') / (norm(Er*Er','fro')*norm(Ep*Ep','fro'));

Fp = zeros([1,n_perms]);

for ii = 1:n_perms
    perms = randperm(size(E,1));
    %Eperm = E(perms,:);
    %M = sign(rand(size(Eperm)) - 0.5);
    %Eperm = Eperm.*M;
    Xperm = X1(perms,:);
    %Xperm = Xhat + Eperm;

    pD1 =  pinv(D1'*D1)*D1';
    Bperm = pD1*Xperm;
    X1perm = D1*Bperm;
    %Es = Xperm - X1perm;
    [~,~,Vpm] = svds(X1perm,rank(X1n));
        
    Tpm = (X1perm) * Vpm;
    [Rp,Pp,T1up,Erp,Epp] = diasmetic_rotations(Tpm,T2o,F1,F2);

    Fp(ii) = trace(Erp*(Erp'*Epp)*Epp') / (norm(Epp*Epp','fro')*norm(Erp*Erp','fro'));
end

p = (sum(Fp <= Fd)+1) / (n_perms + 1); 
%p = Fd;

% Td  = (Fd - mean(Fp)) / std(Fp);
% Tp  = (Fp - mean(Fp)) / std(Fp);
% 
% p = (sum(abs(Td) <= abs(Tp)) + 1) / (n_perms + 1);

end


function [R,P,T1u,Er,Ep] = diasmetic_rotations(T1o,T2o,F1,F2)

[T1u, ord1, ~] = uniquetol(T1o,1e-6, 'ByRows', true, 'PreserveRange', true);
[T2u, ord2, ~] = uniquetol(T2o,1e-6, 'ByRows', true, 'PreserveRange', true);

lvls1 = F1(ord1, 1);
lvls2 = F2(ord2, 1);

%Orient levels according to T1u - should it be opposite?
[~, perm_idx] = ismember(lvls1, lvls2);
n = numel(lvls1);
P = eye(n);
P = P(perm_idx, :);
T2ua = P * T2u;

M = T1u' * T2ua;
[Up, ~, Vp] = svd(M);
R = Up * Vp';  % Rotation matrix
Er = T1u * R - T2ua;

n = size(R, 1);

% Form the cost matrix as the negative absolute value of R
costMat = -abs(R);

% Solve the assignment problem using matchpairs (Hungarian algorithm)
% The second argument (-Inf) ensures a complete assignment.
assignment = matchpairs(costMat, 1e6);

% Initialize the signed permutation matrix P
P = zeros(n);

% For each assignment, set the corresponding entry in P to the sign of R
for k = 1:size(assignment, 1)
    i = assignment(k, 1);
    j = assignment(k, 2);
    if R(i, j) >= 0
        P(i, j) = 1;
    else
        P(i, j) = -1;
    end
end

Ep = T1u*P - T2ua;

%D = diag(sign(diag(T1u'*T2u)));

%T1u = T1u*D;

%T1u = T1u ./vecnorm(T1u);

end


##### SOURCE END #####
-->
</body>
</html>
